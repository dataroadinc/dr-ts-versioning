# Versioning System

This project implements a stateless versioning system that generates changelogs
dynamically during CI/CD builds without committing `CHANGELOG.md` to git.

## Overview

The versioning system is designed to be:

- **Stateless**: No version files are committed to git
- **CI/CD Friendly**: Changelogs are generated during builds
- **Conventional**: Uses conventional commits for automatic versioning
- **Dynamic**: Version information is computed from git history
- **Reusable**: Can be used across multiple projects

## Available Commands

```bash
# Check current version
pnpm version:current

# Bump to next patch version
pnpm version:next

# Generate changelog and update version
pnpm version:release

# CLI commands
npx @dataroadinc/versioning current-version
npx @dataroadinc/versioning next-patch-version
npx @dataroadinc/versioning generate-changelog
npx @dataroadinc/versioning update-package-version

```

## How It Works

### Version Detection

The system determines the current version by:

1. Looking for the latest git tag matching the pattern `v*.*.*`
2. If no tag exists, it defaults to `0.0.0`
3. The version is automatically updated in `package.json`

### Changelog Generation

Changelogs are generated by:

1. Analyzing git commits since the last version tag
2. Grouping commits by conventional commit types (feat, fix, docs, etc.)
3. Organizing changes by scope (project, types, etc.)
4. Including commit hashes and links to GitHub
5. Excluding certain commit types (fix, chore, refactor) by default

### Version Bumping

- **`version:current`**: Updates `package.json` with the current version from
  git tags
- **`version:next`**: Bumps the patch version (e.g., `0.0.1` â†’ `0.0.2`)
- **`version:release`**: Generates changelog and updates to current version

## Git Tags

Version tags follow the semantic versioning format:

- `v0.0.1` - Initial release
- `v0.0.2` - Patch release
- `v0.1.0` - Minor release
- `v1.0.0` - Major release

## Conventional Commits

The system uses conventional commits for automatic categorization:

```

feat(scope): add new feature
fix(scope): fix a bug
docs(scope): update documentation
style(scope): formatting changes
refactor(scope): code refactoring
test(scope): add or update tests
chore(scope): maintenance tasks

```

### Commit Type Labels

The changelog generator uses predefined labels for commit types:

```typescript
const TYPE_LABELS = {
  feat: "Features",
  docs: "Documentation",
  content: "Content",
  partners: "Partners",
  test: "Tests",
  build: "Build System",
  deps: "Dependencies",
  style: "Style",
  perf: "Performance",
}
```

### Ignored Commit Types

The following commit types are automatically excluded from changelog generation:

- `fix` - Bug fixes (typically handled by your release automation)
- `chore` - Maintenance tasks
- `refactor` - Code refactoring

## Version Calculation Logic

- **Main Branch**: When on `main` branch, versions follow the pattern
  `base+count` (e.g., `1.0.0+5`)
- **Feature Branches**: When on other branches, versions follow the pattern
  `base-branch+count` (e.g., `1.0.0-feature-branch+3`)
- **No Tags**: If no git tags exist, falls back to `package.json` version
- **Patch Increment**: `getNextPatchVersion()` always increments the patch
  number

## CI/CD Integration

In CI/CD pipelines:

1. The `CHANGELOG.md` file is generated during builds
2. It's included in the published package
3. The file is properly gitignored to avoid committing it
4. Version information is computed from git history

## Benefits

- **No Version Conflicts**: No manual version file management
- **Automatic Changelogs**: Generated from commit history
- **CI/CD Ready**: Works seamlessly with automated deployments
- **Conventional**: Follows industry standards
- **Stateless**: No version state in repository
- **Reusable**: Can be used across multiple projects

## Example Workflow

```bash
# Make changes and commit with conventional commits
git commit -m "feat(api): add new endpoint"

# Bump version for release
pnpm version:release

# The system will:
# 1. Generate CHANGELOG.md from commits since last tag
# 2. Update package.json with current version
# 3. Create git tag for the new version

```

## File Structure Assumptions

- **Package.json**: Must exist in the current working directory
- **Git Repository**: Must be a git repository with proper history
- **Working Directory**: All operations assume they're run from the project root

## Changelog Format

Generated changelogs follow this structure:

```markdown
# Changelog

## v1.0.1 (2024-01-15)

### Features

**Features:**

- Add new API endpoint ([abc1234](https://github.com/owner/repo/commit/abc1234))

### Documentation

**Documentation:**

- Update README with new examples
  ([def5678](https://github.com/owner/repo/commit/def5678))
```
